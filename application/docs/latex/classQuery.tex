\hypertarget{classQuery}{
\section{Query Class Reference}
\label{classQuery}\index{Query@{Query}}
}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classQuery_afcc3b8a0062df742a516c895ad05eadf}{clear} ()
\item 
\hypertarget{classQuery_ac5a3db6877b1d63b67def06e24bb86cb}{
{\bfseries columns} ()}
\label{classQuery_ac5a3db6877b1d63b67def06e24bb86cb}

\item 
\hypertarget{classQuery_a5e5d7b30a86a5b809137a57a62b684fa}{
{\bfseries count} (\$column= '$\ast$', \$as= 'total')}
\label{classQuery_a5e5d7b30a86a5b809137a57a62b684fa}

\item 
\hypertarget{classQuery_a9ec81787bd0d69ec85987a047915bcb9}{
{\bfseries aggregate} (\$function, \$as= 'aggregate', \$column= '$\ast$')}
\label{classQuery_a9ec81787bd0d69ec85987a047915bcb9}

\item 
\hypertarget{classQuery_ae158383677b601890431921bb035f51b}{
{\bfseries headline} (\$columns, \$query, \$as)}
\label{classQuery_ae158383677b601890431921bb035f51b}

\item 
\hyperlink{classQuery_af44f7bf797779dbbb930e60a53011c6b}{returning} ()
\item 
\hyperlink{classQuery_a92265762363eb9c0255d8167e8274697}{unsafeAggregate} (\$function, \$expression, \$as)
\item 
\hyperlink{classQuery_aaa091145c66718e59db922d065160863}{from} ()
\item 
\hypertarget{classQuery_ade76ff8694567ab372a4f450bb1bcd2e}{
{\bfseries join} (\$table, \$conditions= '', \$type= '')}
\label{classQuery_ade76ff8694567ab372a4f450bb1bcd2e}

\item 
\hyperlink{classQuery_ab1781adb9932c6280373e2abd698f9c8}{where} ()
\item 
\hypertarget{classQuery_a296b505b36d9bc21dfa1608471eabede}{
{\bfseries whereOr} ()}
\label{classQuery_a296b505b36d9bc21dfa1608471eabede}

\item 
\hypertarget{classQuery_a050021933ad19f7394afd8c47bd1e4ed}{
{\bfseries having} ()}
\label{classQuery_a050021933ad19f7394afd8c47bd1e4ed}

\item 
\hypertarget{classQuery_a7810e3ea656afdda873b5985da14386b}{
{\bfseries havingOr} ()}
\label{classQuery_a7810e3ea656afdda873b5985da14386b}

\item 
\hyperlink{classQuery_a0aca93c257130b80f2361b97f1391cc4}{whereFulltext} (\$columns, \$query, \$orNull=false)
\item 
\hypertarget{classQuery_ae9110a507cead8d0c57099aaab273799}{
{\bfseries limit} (\$limit=null, \$offset=0)}
\label{classQuery_ae9110a507cead8d0c57099aaab273799}

\item 
\hypertarget{classQuery_af8940f0c7aede42d1029995396d787ff}{
{\bfseries groupBy} ()}
\label{classQuery_af8940f0c7aede42d1029995396d787ff}

\item 
\hypertarget{classQuery_a89307b4afda564f5ea9afb0733007161}{
{\bfseries orderBy} (\$column, \$direction= 'asc')}
\label{classQuery_a89307b4afda564f5ea9afb0733007161}

\item 
\hypertarget{classQuery_aaffa7dab063581b36110f081a9a16ff8}{
{\bfseries execute} (\$arguments=array(), \$types=null)}
\label{classQuery_aaffa7dab063581b36110f081a9a16ff8}

\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classQuery_af2be941b80c1e376f373ff3d25928a70}{select} ()
\item 
static \hyperlink{classQuery_abbefb2e22d6caa9727832bd60ccb46db}{insert} (\$table, \$values)
\item 
static \hyperlink{classQuery_abcc72cbfecd4b301f964960dad0611e2}{update} (\$table, \$values)
\item 
static \hyperlink{classQuery_a5c5ec3da901616c9b405b686d3d338ab}{delete} (\$table)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
An object of this class represents a query that is being build. Using its functions, the query can be safely (not vulnerable to injections) expanded. The order in which the functions are used is irrelevant, but an exception is thrown when conflicts arise (e.g. when calling update and select on the same object without clearing).

When finished, you can call execute() which executes the query. This method construct a \hyperlink{classResultSet}{ResultSet} and returns it.

{\bfseries Definitions:} The following definitions will be used in the documentation of this class:


\begin{DoxyItemize}
\item SQL identifier: a string representing something like a SQL table or column name. It should start with a letter or underscore and its following characters should be letters, underscores, digits or \$-\/signs. With letters characters in range a-\/z and A-\/Z are meant. SQL supports non-\/ASCII letters but this definition doesn't. Illegal SQL identifiers will be detected when calling prepare() and result in an exception.
\end{DoxyItemize}


\begin{DoxyItemize}
\item SQL value: a UTF-\/8 string or something convertible to that representing a SQL string literal that will be used in the query as a new column value or something a column value can be compared to. These values will be properly escaped, meaning they should be injection-\/proof and can directy depend on user input (assuming there is no bug in the code of the prepare-\/function). (Strings containing) integer and floating point values can be used to represent numeric SQL values. This might not, however, be possible with some other types (like hexadecimal strings representing BLOB's). Use parameter markers for these. Variables that are NULL will be interpreted as a SQL NULL.
\end{DoxyItemize}


\begin{DoxyItemize}
\item Parameter marker: Either a single '?' or a string which first character is a ':', followed by some identifier representing a parameter name. You can only use one style per query: either question marks or named parameters. These markers will be directly placed inside the incomplete query fed to PDO::prepare and allow the database to partially prepare the query, so multiple executions with different parameters will occur faster. After preparation, variables need to bound to these markers using PDOStatement::execute() or PDOStatement::bindValue(). For more information: see \href{http://nl.php.net/manual/en/pdo.prepare.php}{\tt http://nl.php.net/manual/en/pdo.prepare.php}
\end{DoxyItemize}

{\bfseries Chaining} All member function of \hyperlink{}{QueryBuilder}, with the exception of prepare(). Return a reference to the object they were called on (return \$this). This allows 'chaining' operations, as can be seen in the examples.

{\bfseries Examples} \begin{DoxyVerb}
 * 
 * // Simple selection.
 * $qb->select(array('username', 'affiliation'))->from('User')->where(array('userid' => $uid));
 * $stat = $qb->prepare();
 * 
 * // Another selection, with ?-marker.
 * $qb->from('TEIFile')->select()->where(array('createDate' => '<= ?'));
 * 
 * // Building and executing an insertion query with named parameter markers.
 * $stat = $qb->insert('PendingUser', array('pendingUserID'    => ':pid', 
 *                                          'confirmationCode' => ':code',
 *                                          'expirationDate'   => endOfYear()))->prepare();
 * $stat->execute(array(':pid' => $user1, ':code' => generateCode()));
 * $stat->execute(array(':pid' => $user2, ':code' => generateCode()));
 * 
 * // Query which deletes all books from between 1500 and 1512 that are written in either Japanese 
 * // or German.
 * $qb->delete('Book')->where('minYear >= 1500', 'maxYear <= 1512', 
 *                             _or('language LIKE ja%', 'language LIKE de%'));
 * 
 * \end{DoxyVerb}
 

\subsection{Member Function Documentation}
\hypertarget{classQuery_afcc3b8a0062df742a516c895ad05eadf}{
\index{Query@{Query}!clear@{clear}}
\index{clear@{clear}!Query@{Query}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}Query::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classQuery_afcc3b8a0062df742a516c895ad05eadf}
Clears all query elements that have been set. \hypertarget{classQuery_a5c5ec3da901616c9b405b686d3d338ab}{
\index{Query@{Query}!delete@{delete}}
\index{delete@{delete}!Query@{Query}}
\subsubsection[{delete}]{\setlength{\rightskip}{0pt plus 5cm}static Query::delete (
\begin{DoxyParamCaption}
\item[{\$}]{table}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classQuery_a5c5ec3da901616c9b405b686d3d338ab}
Determine the query should be a DELETE-\/statement. Should generally be followed by a where.


\begin{DoxyParams}[1]{Parameters}
string & {\em \$table} & The table from which to delete. \\
\hline
\end{DoxyParams}
\hypertarget{classQuery_aaa091145c66718e59db922d065160863}{
\index{Query@{Query}!from@{from}}
\index{from@{from}!Query@{Query}}
\subsubsection[{from}]{\setlength{\rightskip}{0pt plus 5cm}Query::from (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classQuery_aaa091145c66718e59db922d065160863}
When constructing a SELECT-\/statement, specifies which table(s) to select from.


\begin{DoxyParams}{Parameters}
{\em string/array} & \$tables An array of SQL identifiers representing tables to select from. It's also possible to specify a single string, which will be interpreted as an array containing only that. \\
\hline
\end{DoxyParams}
\hypertarget{classQuery_abbefb2e22d6caa9727832bd60ccb46db}{
\index{Query@{Query}!insert@{insert}}
\index{insert@{insert}!Query@{Query}}
\subsubsection[{insert}]{\setlength{\rightskip}{0pt plus 5cm}static Query::insert (
\begin{DoxyParamCaption}
\item[{\$}]{table, }
\item[{\$}]{values}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classQuery_abbefb2e22d6caa9727832bd60ccb46db}
Determines the query should be an INSERT-\/statement and specifies its parameters.


\begin{DoxyParams}[1]{Parameters}
string & {\em \$table} & The name of the table in which to insert. \\
\hline
array & {\em \$vals} & An associative array with column names as keys and as values parameter marks or SQL values. \\
\hline
\end{DoxyParams}
\hypertarget{classQuery_af44f7bf797779dbbb930e60a53011c6b}{
\index{Query@{Query}!returning@{returning}}
\index{returning@{returning}!Query@{Query}}
\subsubsection[{returning}]{\setlength{\rightskip}{0pt plus 5cm}Query::returning (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classQuery_af44f7bf797779dbbb930e60a53011c6b}
Specifies a column to be added to the returning clause.

Returning is a very useful PostgreSQL feature. See also the PostgreSQL documentation at \href{http://www.postgresql.org/docs/9.1/static/sql-insert.html}{\tt http://www.postgresql.org/docs/9.1/static/sql-\/insert.html}


\begin{DoxyParams}{Parameters}
{\em string} & ... The names of the column of which the value should be added to the result set. \\
\hline
\end{DoxyParams}
\hypertarget{classQuery_af2be941b80c1e376f373ff3d25928a70}{
\index{Query@{Query}!select@{select}}
\index{select@{select}!Query@{Query}}
\subsubsection[{select}]{\setlength{\rightskip}{0pt plus 5cm}static Query::select (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classQuery_af2be941b80c1e376f373ff3d25928a70}
Determines the query should be a SELECT-\/statement, if not yet the case, and specifies which columns should be selected. If already called on the same object before, it will extend the columns to be selected. If a single select with no argument or an empty array has been made, all columns will be selected.


\begin{DoxyParams}{Parameters}
{\em ...} & SQL Identifiers representing columns to limit the result of the selection to. \\
\hline
\end{DoxyParams}
\hypertarget{classQuery_a92265762363eb9c0255d8167e8274697}{
\index{Query@{Query}!unsafeAggregate@{unsafeAggregate}}
\index{unsafeAggregate@{unsafeAggregate}!Query@{Query}}
\subsubsection[{unsafeAggregate}]{\setlength{\rightskip}{0pt plus 5cm}Query::unsafeAggregate (
\begin{DoxyParamCaption}
\item[{\$}]{function, }
\item[{\$}]{expression, }
\item[{\$}]{as}
\end{DoxyParamCaption}
)}}
\label{classQuery_a92265762363eb9c0255d8167e8274697}
Unsafe aggregate function. Handle with care! \hypertarget{classQuery_abcc72cbfecd4b301f964960dad0611e2}{
\index{Query@{Query}!update@{update}}
\index{update@{update}!Query@{Query}}
\subsubsection[{update}]{\setlength{\rightskip}{0pt plus 5cm}static Query::update (
\begin{DoxyParamCaption}
\item[{\$}]{table, }
\item[{\$}]{values}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classQuery_abcc72cbfecd4b301f964960dad0611e2}
Determines the query should be an UPDATE-\/statement and specifies its parameters. Can (and usually should) be followed by a where.


\begin{DoxyParams}[1]{Parameters}
string & {\em \$table} & The name of the table in which to update rows. \\
\hline
array & {\em \$vals} & An associative array with column names as keys and as values parameter marks or SQL values. \\
\hline
\end{DoxyParams}
\hypertarget{classQuery_ab1781adb9932c6280373e2abd698f9c8}{
\index{Query@{Query}!where@{where}}
\index{where@{where}!Query@{Query}}
\subsubsection[{where}]{\setlength{\rightskip}{0pt plus 5cm}Query::where (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classQuery_ab1781adb9932c6280373e2abd698f9c8}
Specify the a condition of a query. Each argument should be a string containing a predicate that will be directly placed in the where-\/statement of the query. \hyperlink{classNote}{Note} that its contents will NOT be escaped or validated, so make sure they do not directly depend on user input. Parameter markers should be used instead.

The currently supported operators are '$<$','$>$','$>$=','$<$=', '=','==', 'is','like', 'ilike', '!=', '$<$$>$', 'not is', 'not like', 'not ilike', 'overlaps', 'in' and 'not in'. Operators are case insensitive.

The arguments are separated by a logical AND's. Use whereOr to separate them with OR's. \hypertarget{classQuery_a0aca93c257130b80f2361b97f1391cc4}{
\index{Query@{Query}!whereFulltext@{whereFulltext}}
\index{whereFulltext@{whereFulltext}!Query@{Query}}
\subsubsection[{whereFulltext}]{\setlength{\rightskip}{0pt plus 5cm}Query::whereFulltext (
\begin{DoxyParamCaption}
\item[{\$}]{columns, }
\item[{\$}]{query, }
\item[{\$}]{orNull = {\ttfamily false}}
\end{DoxyParamCaption}
)}}
\label{classQuery_a0aca93c257130b80f2361b97f1391cc4}
A specific where implementation for fulltext searches. 

The documentation for this class was generated from the following file:\begin{DoxyCompactItemize}
\item 
www/backend/framework/database/query.php\end{DoxyCompactItemize}
